{"version":3,"sources":["../../../../../../apps/web/components/projects/project-workspace.tsx/__nextjs-internal-proxy.mjs","../../../../../../apps/web/lib/server/s3.ts","../../../../../../apps/web/lib/server/domain.ts","../../../../../../apps/web/app/projects/%5BprojectId%5D/page.tsx"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const ProjectWorkspace = registerClientReference(\n    function() { throw new Error(\"Attempted to call ProjectWorkspace() from the server but ProjectWorkspace is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/web/components/projects/project-workspace.tsx\",\n    \"ProjectWorkspace\",\n);\n","import {\n  CompleteMultipartUploadCommand,\n  CreateMultipartUploadCommand,\n  DeleteObjectCommand,\n  GetObjectCommand,\n  PutObjectCommand,\n  S3Client,\n  UploadPartCommand,\n  type CompletedPart\n} from \"@aws-sdk/client-s3\";\nimport { getSignedUrl } from \"@aws-sdk/s3-request-presigner\";\n\nimport { env } from \"./env\";\n\nexport const s3Client = new S3Client({\n  endpoint: env.MINIO_ENDPOINT,\n  forcePathStyle: true,\n  region: env.MINIO_REGION,\n  credentials: {\n    accessKeyId: env.MINIO_ACCESS_KEY,\n    secretAccessKey: env.MINIO_SECRET_KEY\n  }\n});\n\nexport async function createMultipartUpload(params: {\n  key: string;\n  contentType: string;\n  metadata?: Record<string, string>;\n}) {\n  const command = new CreateMultipartUploadCommand({\n    Bucket: env.MINIO_BUCKET,\n    Key: params.key,\n    ContentType: params.contentType,\n    Metadata: params.metadata\n  });\n\n  return s3Client.send(command);\n}\n\nexport async function getMultipartUploadPartSignedUrl(params: {\n  key: string;\n  uploadId: string;\n  partNumber: number;\n}) {\n  const command = new UploadPartCommand({\n    Bucket: env.MINIO_BUCKET,\n    Key: params.key,\n    UploadId: params.uploadId,\n    PartNumber: params.partNumber\n  });\n\n  return getSignedUrl(s3Client, command, { expiresIn: 900 });\n}\n\nexport async function getPutObjectSignedUrl(params: {\n  key: string;\n  contentType: string;\n  expiresInSeconds?: number;\n}) {\n  const command = new PutObjectCommand({\n    Bucket: env.MINIO_BUCKET,\n    Key: params.key,\n    ContentType: params.contentType\n  });\n\n  return getSignedUrl(s3Client, command, {\n    expiresIn: params.expiresInSeconds ?? 900\n  });\n}\n\nexport async function completeMultipartUpload(params: {\n  key: string;\n  uploadId: string;\n  parts: CompletedPart[];\n}) {\n  const command = new CompleteMultipartUploadCommand({\n    Bucket: env.MINIO_BUCKET,\n    Key: params.key,\n    UploadId: params.uploadId,\n    MultipartUpload: {\n      Parts: params.parts\n    }\n  });\n\n  return s3Client.send(command);\n}\n\nexport async function getObjectSignedUrl(key: string, expiresInSeconds = 900) {\n  const command = new GetObjectCommand({\n    Bucket: env.MINIO_BUCKET,\n    Key: key\n  });\n\n  return getSignedUrl(s3Client, command, { expiresIn: expiresInSeconds });\n}\n\nexport async function putObject(params: {\n  key: string;\n  body: string | Uint8Array;\n  contentType: string;\n}) {\n  const command = new PutObjectCommand({\n    Bucket: env.MINIO_BUCKET,\n    Key: params.key,\n    Body: params.body,\n    ContentType: params.contentType\n  });\n\n  return s3Client.send(command);\n}\n\nexport async function deleteObject(key: string) {\n  return s3Client.send(\n    new DeleteObjectCommand({\n      Bucket: env.MINIO_BUCKET,\n      Key: key\n    })\n  );\n}\n\nexport async function getObjectText(key: string): Promise<string | null> {\n  const response = await s3Client.send(\n    new GetObjectCommand({\n      Bucket: env.MINIO_BUCKET,\n      Key: key\n    })\n  );\n\n  if (!response.Body) {\n    return null;\n  }\n\n  const streamText = await response.Body.transformToString();\n  return streamText;\n}\n","import { randomUUID } from \"node:crypto\";\n\nimport {\n  and,\n  desc,\n  eq,\n  sql\n} from \"drizzle-orm\";\n\nimport {\n  createContentFingerprint,\n  detectLanguageFromPath,\n  normalizePath,\n  type Language,\n  projects,\n  projectMembers,\n  revisions,\n  revisionFiles,\n  uploads,\n  workingCopies,\n  workingCopyFiles,\n  fileBlobs,\n  auditRuns,\n  findingTransitions,\n  pdfExports\n} from \"@ton-audit/shared\";\n\nimport { db } from \"./db\";\nimport { getObjectText, putObject } from \"./s3\";\n\nexport async function ensureProjectAccess(projectId: string, userId: string) {\n  const ownedProject = await db.query.projects.findFirst({\n    where: and(eq(projects.id, projectId), eq(projects.ownerUserId, userId))\n  });\n\n  if (ownedProject) {\n    return ownedProject;\n  }\n\n  const membership = await db.query.projectMembers.findFirst({\n    where: and(eq(projectMembers.projectId, projectId), eq(projectMembers.userId, userId))\n  });\n\n  if (!membership) {\n    return null;\n  }\n\n  return db.query.projects.findFirst({\n    where: eq(projects.id, projectId)\n  });\n}\n\nexport async function createProject(input: {\n  ownerUserId: string;\n  name: string;\n  slug: string;\n}) {\n  const [project] = await db\n    .insert(projects)\n    .values({\n      ownerUserId: input.ownerUserId,\n      name: input.name,\n      slug: input.slug\n    })\n    .returning();\n\n  if (!project) {\n    throw new Error(\"Failed to create project\");\n  }\n\n  await db.insert(projectMembers).values({\n    projectId: project.id,\n    userId: input.ownerUserId,\n    role: \"owner\"\n  });\n\n  return project;\n}\n\nexport async function createRevisionFromUpload(params: {\n  projectId: string;\n  uploadId: string;\n  createdByUserId: string;\n}) {\n  const uploadRecord = await db.query.uploads.findFirst({\n    where: and(eq(uploads.id, params.uploadId), eq(uploads.projectId, params.projectId))\n  });\n\n  if (!uploadRecord) {\n    throw new Error(\"Upload not found\");\n  }\n\n  const [latestRevision] = await db\n    .select()\n    .from(revisions)\n    .where(eq(revisions.projectId, params.projectId))\n    .orderBy(desc(revisions.createdAt))\n    .limit(1);\n\n  const [revision] = await db\n    .insert(revisions)\n    .values({\n      projectId: params.projectId,\n      parentRevisionId: latestRevision?.id ?? null,\n      source: \"upload\",\n      createdByUserId: params.createdByUserId,\n      isImmutable: true,\n      description: `Revision from upload ${params.uploadId}`\n    })\n    .returning();\n\n  if (!revision) {\n    throw new Error(\"Failed to create revision\");\n  }\n\n  return { revision, uploadRecord };\n}\n\nexport async function createWorkingCopy(params: {\n  projectId: string;\n  revisionId: string;\n  ownerUserId: string;\n}) {\n  const [workingCopy] = await db\n    .insert(workingCopies)\n    .values({\n      projectId: params.projectId,\n      baseRevisionId: params.revisionId,\n      ownerUserId: params.ownerUserId,\n      status: \"active\"\n    })\n    .returning();\n\n  if (!workingCopy) {\n    throw new Error(\"Unable to create working copy\");\n  }\n\n  const revisionRows = await db\n    .select({\n      path: revisionFiles.path,\n      language: revisionFiles.language,\n      isTestFile: revisionFiles.isTestFile,\n      s3Key: fileBlobs.s3Key,\n      contentType: fileBlobs.contentType\n    })\n    .from(revisionFiles)\n    .innerJoin(fileBlobs, eq(revisionFiles.blobId, fileBlobs.id))\n    .where(eq(revisionFiles.revisionId, params.revisionId));\n\n  if (revisionRows.length) {\n    const workingFiles = await Promise.all(\n      revisionRows.map(async (row) => ({\n        workingCopyId: workingCopy.id,\n        path: row.path,\n        language: row.language,\n        content: (await getObjectText(row.s3Key)) ?? \"\",\n        isTestFile: row.isTestFile\n      }))\n    );\n\n    await db.insert(workingCopyFiles).values(workingFiles);\n  }\n\n  return workingCopy;\n}\n\nexport async function saveWorkingCopyFile(params: {\n  workingCopyId: string;\n  path: string;\n  content: string;\n  language?: Language;\n  isTestFile?: boolean;\n}) {\n  const normalizedPath = normalizePath(params.path);\n  const language = params.language ?? detectLanguageFromPath(normalizedPath);\n\n  const current = await db.query.workingCopyFiles.findFirst({\n    where: and(\n      eq(workingCopyFiles.workingCopyId, params.workingCopyId),\n      eq(workingCopyFiles.path, normalizedPath)\n    )\n  });\n\n  if (current) {\n    const [updated] = await db\n      .update(workingCopyFiles)\n      .set({\n        content: params.content,\n        language,\n        isTestFile: params.isTestFile ?? current.isTestFile,\n        updatedAt: new Date()\n      })\n      .where(\n        and(\n          eq(workingCopyFiles.workingCopyId, params.workingCopyId),\n          eq(workingCopyFiles.path, normalizedPath)\n        )\n      )\n      .returning();\n\n    return updated;\n  }\n\n  const [created] = await db\n    .insert(workingCopyFiles)\n    .values({\n      workingCopyId: params.workingCopyId,\n      path: normalizedPath,\n      language,\n      content: params.content,\n      isTestFile: params.isTestFile ?? false\n    })\n    .returning();\n\n  return created;\n}\n\nexport async function snapshotWorkingCopyAndCreateAuditRun(params: {\n  projectId: string;\n  workingCopyId: string;\n  userId: string;\n  primaryModelId: string;\n  fallbackModelId: string;\n}) {\n  const workingCopy = await db.query.workingCopies.findFirst({\n    where: and(\n      eq(workingCopies.id, params.workingCopyId),\n      eq(workingCopies.projectId, params.projectId),\n      eq(workingCopies.ownerUserId, params.userId)\n    )\n  });\n\n  if (!workingCopy) {\n    throw new Error(\"Working copy not found\");\n  }\n\n  const [revision] = await db\n    .insert(revisions)\n    .values({\n      projectId: params.projectId,\n      parentRevisionId: workingCopy.baseRevisionId,\n      source: \"working-copy\",\n      createdByUserId: params.userId,\n      isImmutable: true,\n      description: `Snapshot from working copy ${workingCopy.id}`\n    })\n    .returning();\n\n  if (!revision) {\n    throw new Error(\"Failed to create snapshot revision\");\n  }\n\n  const files = await db.query.workingCopyFiles.findMany({\n    where: eq(workingCopyFiles.workingCopyId, params.workingCopyId)\n  });\n\n  if (files.length) {\n    const insertedBlobs = await Promise.all(\n      files.map(async (file) => {\n        const sha = createContentFingerprint(file.content);\n        const existing = await db.query.fileBlobs.findFirst({\n          where: eq(fileBlobs.sha256, sha)\n        });\n\n        if (existing) {\n          return existing;\n        }\n\n        const s3Key = `revisions/${revision.id}/files/${randomUUID()}`;\n        await putObject({\n          key: s3Key,\n          body: file.content,\n          contentType: \"text/plain; charset=utf-8\"\n        });\n\n        const [createdBlob] = await db\n          .insert(fileBlobs)\n          .values({\n            sha256: sha,\n            sizeBytes: Buffer.byteLength(file.content, \"utf8\"),\n            s3Key,\n            contentType: \"text/plain; charset=utf-8\"\n          })\n          .returning();\n\n        if (!createdBlob) {\n          throw new Error(`Failed to persist blob for ${file.path}`);\n        }\n\n        return createdBlob;\n      })\n    );\n\n    await db.insert(revisionFiles).values(\n      files.map((file, index) => ({\n        revisionId: revision.id,\n        path: file.path,\n        language: file.language,\n        blobId: insertedBlobs[index]?.id ?? insertedBlobs[0]!.id,\n        isTestFile: file.isTestFile\n      }))\n    );\n  }\n\n  const [auditRun] = await db\n    .insert(auditRuns)\n    .values({\n      projectId: params.projectId,\n      revisionId: revision.id,\n      status: \"queued\",\n      requestedByUserId: params.userId,\n      primaryModelId: params.primaryModelId,\n      fallbackModelId: params.fallbackModelId\n    })\n    .returning();\n\n  if (!auditRun) {\n    throw new Error(\"Failed to create audit run\");\n  }\n\n  return { revision, auditRun };\n}\n\nexport async function getAuditDiff(projectId: string, auditRunId: string) {\n  const auditRun = await db.query.auditRuns.findFirst({\n    where: and(eq(auditRuns.id, auditRunId), eq(auditRuns.projectId, projectId))\n  });\n\n  if (!auditRun) {\n    return null;\n  }\n\n  const revision = await db.query.revisions.findFirst({\n    where: eq(revisions.id, auditRun.revisionId)\n  });\n\n  if (!revision) {\n    return null;\n  }\n\n  const prevAudit = await db\n    .select()\n    .from(auditRuns)\n    .where(\n      and(\n        eq(auditRuns.projectId, projectId),\n        eq(auditRuns.status, \"completed\"),\n        sql`${auditRuns.createdAt} < ${auditRun.createdAt}`\n      )\n    )\n    .orderBy(desc(auditRuns.createdAt))\n    .limit(1);\n\n  const currentFiles = await db\n    .select({ path: revisionFiles.path })\n    .from(revisionFiles)\n    .where(eq(revisionFiles.revisionId, revision.id));\n\n  const previousFiles = prevAudit[0]\n    ? await db\n        .select({ path: revisionFiles.path })\n        .from(revisionFiles)\n        .where(eq(revisionFiles.revisionId, prevAudit[0].revisionId))\n    : [];\n\n  const currentSet = new Set(currentFiles.map((file) => file.path));\n  const previousSet = new Set(previousFiles.map((file) => file.path));\n\n  const added = [...currentSet].filter((path) => !previousSet.has(path));\n  const removed = [...previousSet].filter((path) => !currentSet.has(path));\n  const unchanged = [...currentSet].filter((path) => previousSet.has(path));\n\n  const transitions = await db.query.findingTransitions.findMany({\n    where: eq(findingTransitions.toAuditRunId, auditRunId)\n  });\n\n  return {\n    auditRun,\n    files: {\n      added,\n      removed,\n      unchanged\n    },\n    transitions\n  };\n}\n\nexport async function findAuditRunWithProject(projectId: string, auditRunId: string) {\n  return db.query.auditRuns.findFirst({\n    where: and(eq(auditRuns.id, auditRunId), eq(auditRuns.projectId, projectId))\n  });\n}\n\nexport async function getLatestProjectState(projectId: string) {\n  const [latestRevision] = await db\n    .select()\n    .from(revisions)\n    .where(eq(revisions.projectId, projectId))\n    .orderBy(desc(revisions.createdAt))\n    .limit(1);\n\n  const [latestAudit] = await db\n    .select()\n    .from(auditRuns)\n    .where(eq(auditRuns.projectId, projectId))\n    .orderBy(desc(auditRuns.createdAt))\n    .limit(1);\n\n  return {\n    latestRevision,\n    latestAudit\n  };\n}\n\nexport async function queryProjectAudits(projectId: string) {\n  return db\n    .select()\n    .from(auditRuns)\n    .where(eq(auditRuns.projectId, projectId))\n    .orderBy(desc(auditRuns.createdAt));\n}\n\nexport async function createPdfExport(auditRunId: string) {\n  const [record] = await db\n    .insert(pdfExports)\n    .values({\n      auditRunId,\n      status: \"queued\"\n    })\n    .onConflictDoUpdate({\n      target: pdfExports.auditRunId,\n      set: {\n        status: \"queued\",\n        updatedAt: new Date()\n      }\n    })\n    .returning();\n\n  return record;\n}\n\nexport async function getPdfExportByAudit(auditRunId: string) {\n  return db.query.pdfExports.findFirst({\n    where: eq(pdfExports.auditRunId, auditRunId)\n  });\n}\n","import Link from \"next/link\";\nimport { notFound } from \"next/navigation\";\n\nimport { ProjectWorkspace } from \"@/components/projects/project-workspace\";\nimport { ensureProjectAccess, getLatestProjectState } from \"@/lib/server/domain\";\nimport { env } from \"@/lib/server/env\";\nimport { requireServerSession } from \"@/lib/server/session\";\n\nexport default async function ProjectPage(props: {\n  params: Promise<{ projectId: string }>;\n}) {\n  const session = await requireServerSession();\n  const { projectId } = await props.params;\n\n  const project = await ensureProjectAccess(projectId, session.user.id);\n  if (!project) {\n    notFound();\n  }\n\n  const latest = await getLatestProjectState(project.id);\n\n  return (\n    <main className=\"min-h-screen bg-[#0b0f15] text-zinc-100\">\n      <div className=\"mx-auto grid max-w-[1500px] gap-4 px-4 py-5 lg:px-6\">\n        <header className=\"flex flex-wrap items-center justify-between gap-2\">\n          <div>\n            <p className=\"text-xs uppercase tracking-wide text-zinc-500\">Project</p>\n            <h1 className=\"text-xl font-semibold\">{project.name}</h1>\n          </div>\n          <Link href=\"/dashboard\" className=\"text-sm text-sky-300 hover:text-sky-200\">\n            Back to dashboard\n          </Link>\n        </header>\n\n        <ProjectWorkspace\n          projectId={project.id}\n          initialRevisionId={latest.latestRevision?.id ?? null}\n          initialAuditId={latest.latestAudit?.id ?? null}\n          modelAllowlist={env.AUDIT_MODEL_ALLOWLIST}\n        />\n      </div>\n    </main>\n  );\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}